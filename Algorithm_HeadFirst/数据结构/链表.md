## 数组模拟单链表

应用场景：最多的就是邻接表

邻接表最主要的应用就是存储图和树

![数组模拟单链表-1](../pic/数组模拟单链表-1.png)



### 插入操作

```java
// 表示头节点的下标
int head;
// 存储当前已经用到了哪个点
int idx;
// e[i]表示节点i的值
int[] e;
// ne[i]表示节点i的next指针是多少
int[] ne;

// 将x插入到头节点
void addToHead(int x) {
  e[idx] = x;
  ne[idx] = head;  // 新节点的next指针指向head指向的节点
  head = idx++;  // 更新head指针，即新节点为头节点，同时idx++
}

// 将值为x的新节点插入到下标为k的节点的后面
void add(int k, int x) {
  e[idx] = x;
  ne[idx] = ne[k];
  ne[k] = idx++;
}
```



### 删除操作

```java
// 删除下标是k的点后面的节点
void remove(int k) {
  ne[k] = ne[ne[k]];
}
```



## 数组模拟双链表

```java
// 左边存储
int[] l;
// 右边存储
int[] r;
// 元素值
int[] e;
// 当前节点存储的位置
int idx;


// 初始化
// 下标为0是左端点，下标为1是右端点
void init() {
  r[0] = 1;
  l[1] = 0;
  idx = 2;
}

// 插入，在下标为k的点的后面插入值为x的节点
void add(int k, int x) {
  e[idx] = x;
  r[idx] = r[k];
  l[idx] = k;
  l[r[k]] = idx;
  r[k] = idx;
  idx++;
}


// 删除第k个点
void remove(int k) {
  r[l[k]] = r[k];
  l[r[k]] = l[k];
}
```



## 总结

链表题目的解题思路：

- 建一个「虚拟头节点」dummy 以减少边界判断，往后的答案链表会接在 dummy 后面
- 使用 tail 代表当前有效链表的结尾
- 通过原输入的 head 指针进行链表扫描



类型：

- 快慢指针：即slow走一步，fast走两步 
  - 可以用来找到链表的中心
  - 环形链表可以用，a  = (n - 1) (b + c) + b
- 双指针：两个指针，一个先走n步，然后同时走
- 可以设置dummyNode节点，这样可以将头节点也作为一般节点，统计处理
- 链表适合什么排序？ 
  - 归并排序 
    - 归并排序：先划分，然后合并。划分到每个数组是单调的
- 递归一定遵循三步走 
  - 递归结束的条件
  - 本次执行的逻辑
  - 本次的返回值
- 节点的删除，需要考虑头节点，所以一般会设置dummyNode 
  - 链表节点的删除，一般需要找到前驱节点



为什么要用数组模拟链表？

因为快，创建对象耗时















