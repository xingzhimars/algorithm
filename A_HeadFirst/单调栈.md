## 单调栈

每个数左边离它最近的比它小的数在什么地方？一般都是这种题型

类型单一，就几种题目



1. 单调栈其实就是在栈的基础上，维持一个栈内元素单调
2. 找某侧最近一个比其大的值，使用单调栈维持栈内元素递减；找某侧最近一个比其小的值，使用单调栈维持栈内元素递增
3. 如果是单调增，考虑前后都加上0，边界case，可以看下84题。因为下标为0的矩形也需要计算



代码有一定的格式，如下：

```java
for (int i = 0; i < n; i++) {
  // 不符合单调减了，单调增也是同理的
  while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
    // 具体逻辑
  }
  stack.push(i);
}
```



## 示例

分成四种情况：

1. 元素A左侧第一个比它大的元素
2. 元素A左侧第一个比它小的元素
3. 元素B右侧第一个比它大的元素
4. 元素B右侧第一个比它小的元素



### 元素A左侧第一个比它大的元素

元素A左侧第一个比它大的元素C，首先肯定是单调减

```java
for (int i = 0; i < n; i++) {
  
  while (tt > 0 && nums[i] >= nums[st[tt]]) {
    tt--;
  }
  int val = -1;
  it (tt > 0) {
    val = nums[st[tt]];
  }
  ans[i] = val;
  
  tt++;
  st[tt] = i;
}
```



### 元素A左侧第一个比它小的元素

```java
for (int i = 0; i < n; i++) {
  while (tt > 0 && nums[i] <= nums[st[tt]]) {
    tt--;
  }
  int val = -1;
  if (tt > 0) {
    val = nums[st[tt]];
  }
  ans[i] = val;
  
  tt++;
  st[tt] = i;
}
```



### 元素B右侧第一个比它大的元素

元素B右侧第一个比它大的元素C，首先明确一下，这个是单调减，有两种做法，分别对应顺序和逆序。

仔细对比一下两者的区别，两者相对的参考是不一样的，一个是固定元素C，一个是固定元素B，由于固定的元素不同，因此逻辑写在不同的地方，一个是在回退栈的过程中处理，一个是在回退栈之后处理。

```java
for (int i = 0; i < n; i++) {
  while (tt > 0 && nums[i] > nums[st[tt]]) {
    // 对于下标为st[tt]的元素，其右侧第一个比它大的元素为nums[i]
    ans[st[tt]] = nums[i];
    tt--;
  }
  
  tt++;
  st[tt] = i;
}
```



### 元素B右侧第一个比它小的元素

```java
for (int i = 0; i < n; i++) {
  while (tt > 0 && nums[i] < nums[st[tt]]) {
    ans[st[tt]] = nums[i];
    tt--;
  }
  
  tt++;
  st[tt] = i;
}
```



## 总结

1. 第一个比它大，第一个比它小，对应的是栈的单调性；比它大，对应单调减；比它小，对应单调增；与右侧，还是左侧无关
2. 比它大，或者大于等于，对应到代码中就是nums[i]与nums[stack[tt]]的大小关系中是否要加等号，这个可以先将代码写出来，然后再考虑
3. 顺序或者逆序都是可以解决问题的，关键在于哪个是A，哪个是B，有一个相对关系，这个相对关系和顺序或逆序有关
4. 推荐，自己就按照顺序方式写，求左侧，处理逻辑写在内部for循环外；求右侧，处理逻辑写在内部for循环里



**重点**：

1. 比它大，单调减；比它小，单调增
2. 求左侧，逻辑写到内部for循环外；求右侧，逻辑写到内部for循环内